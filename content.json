{"pages":[{"title":"","text":"In me the tiger sniffs the rose!心有猛虎，细嗅蔷薇！","link":"/about/index.html"}],"posts":[{"title":"Webflux 介绍","text":"Webflux目的与用户打交道 why created?1.基于函数式编程2.使用固定的线程和硬件资源处理并发 两种编程模型 基于注解的 controller 函数式端点Functional Endpoints Router与Handler RouterFunctions可以产生Router和Handler对象， RouterFunctions对标@Controller中的注解 Router相当于@RequestMapping Handler相当于Controller中的方法 ServerRequest和ServerResponse SpringMVC中使用的是HTTPServletRequest webFlux + SpringMVC 使用的是ServerHTTPRequest WebFlux+ 响应式 使用的是 ServerRequest 和 Spring MVC 区别IO 密集度较高，使用性能较好 使用 netty 作为 web 容器 基于注解的 WebFlux 阻塞式与响应式实现 WebFlux + SSE 服务器推 传统的SpringMVC注解与WebFlux通用，区别在于底层实现，WebFlux 中的 ServerHttpRequest 与 SpringMVC HTTPServletRequest 的区别 官网建议 如果 Spring MVC 用的好好的，不需要切换，命令式更好写，懂，debug 微服务架构，可以混合使用 如果使用了阻塞的持久化框架，如 JPA,JDBC，最好的选择就是 Spring MVC 陡峭的学习路线 处理请求类 HttpHandler 非阻塞 http 请求处理 WebHandler 高级一点，web api 的请求处理 WebSocket vs. HTTP http 只能由客户端发起连接，服务端作出响应 无状态：每次连接处理一个请求，请求结束后断开连接 无连接： 对于事务处理没有记忆能力，服务器不知道客户端是什么状态 缺陷：通信只能由客户端发起，如果服务器有连续的变化，客户端很难得知 基于http实现即时通讯 轮询: ajax 长轮询： ajax 请求，服务器 hold 住连接 长连接： 嵌入 iframe，长连接的请求，服务器不断输入数据 Flash Socket：内嵌 socket 类的 flash 程序，js 调用 flash，socket 通信 websockets 2008 诞生，2011 成为标准，浏览器支持 服务器主动向客户端推送消息，客户端也可以主动向服务器发送信息，全双工通信 建立握手连接是通过 http 传输的，建立之后，传输不需要 http 协议","link":"/2021/08/13/Webflux-%E4%BB%8B%E7%BB%8D/"},{"title":"MySQL的执行计划","text":"基于 MySQL 8.0 community 的版本 用 EXPLAN 来优化查询EXPLAIN 输出的格式说明官网参考文档 Understanding the Query Execution Plan","link":"/2021/08/19/mysql-execution-plan/"},{"title":"project-reactor","text":"概述真正的响应式，服务端实现，实现了 Reactive Streams 规范 what’s reactor 一个基于事件，异步处理高并发服务请求的框架，集成了 java 8的 函数式 api CompletableFuture Steam Duration 通过reactor-netty支持非阻塞进程间通信 适合微服务架构 Reactor Netty 提供 HTTP（包括 Websockets）, TCP, UDP 的背压就绪网络引擎 hot/cold cold 为每一个订阅都重新生成数据，从头开始，总能收到产生的全部数据 defer（每次订阅都是相同的返回） hot 持续不断的产生消息，订阅者只能获取订阅之后产生的消息 just share replay 提供 Flux/Mono return 一个 mono, 先返回 mono ，这个 mono 包装好各种方法， 把 方法放到调用里面，看起来是异步，实际上同步，只不过阻塞是发生在 Web 容器（Netty）里面 Router 约等于 @Controller + @RequestMapping Handler controller 里面的方法 create 可以创建 Mono, Flux，异步 generate 只能生成 Flux，同步 Disposable cancel-and-clean-up，stop producing values and clean up any resources it created Mono onNext 和 onError 不能同时用，因为最多一个 single 弹珠图 怎么阅读弹珠图","link":"/2021/08/17/project-reactor/"},{"title":"reactive-programming","text":"what ？ 响应式宣言 一个基于面向数据流和传播变化的异步编程模型 和 Java 8 Streams 以及 Iterable-Iterator 比较 reactive 是 推模型, events 来了，推到 subscriber Java 8 Streams 以及 Iterable-Iterator 是 拉模型 背压流量控制: 告诉上游自己需要多少数据 如果不能 slow down， 只能 buffer ， drop or fail 在数据流从上游生产者向下游消费者传输的过程中，上游生产速度大于下游消费速度，导致下游的 Buffer 溢出，这种现象就叫做 Backpressure 出现。 规范标准，就是一个接口 publisher subscriber subscription processor 实现 webflux参考 webflux 文章 Project Reactor参考 Project Reactor 文章 RxJava 较老 main 里面同步 加 Scheduler，异步 响应式数据库 底层连接协议如何与数据库建立通讯 springJDBC -&gt; JDBC 规范 -&gt; mysql jdbc Driver -&gt; mysql R2DBC Drivers All terminal methods always return a Publisher type that represents the desired operation. The actual statements are sent to the database upon subscription. how总结来说，实际上就是：“异步编程，事件驱动” 消息驱动 同步与异步 callable BiFunction 同步：哪个线程产生就在哪个线程消费 命令式编程与响应式编程 函数式编程Functional Programming “what to solve” 命令式编程 “how to solve” 基于 lamda calculus 编程范式，编程程序的方法论 观察者模式 Tomcat 的 NIO 异步网络 IO 服务器推技术 Servlet 3.0 与 3.1 why ?一句话：提高性能 使用更多的线程和硬件资源来提高并行度 提高现有资源的使用效率","link":"/2021/08/17/reactive-programming/"}],"tags":[{"name":"web","slug":"web","link":"/tags/web/"},{"name":"mysql","slug":"mysql","link":"/tags/mysql/"},{"name":"reactive","slug":"reactive","link":"/tags/reactive/"}],"categories":[{"name":"响应式编程","slug":"响应式编程","link":"/categories/%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B/"},{"name":"数据库","slug":"数据库","link":"/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]}